%% Date: 05.01.17 - 10:21
%% â’¸ 2017 heyoka
-module(esp_stream_in).
-author("Alexander Minichmair").

-behaviour(df_component).

-include("faxe.hrl").
%% API
-export([init/3, process/3, handle_info/2, options/0]).
-record(state, {
   node_id           :: term(),
   key               :: binary(),
   stream_ids = []   :: list(binary()),
   data_handler      :: pid(),
   prefetch   = 1    :: non_neg_integer()
}).

options() ->
   [{stream_ids, list}, {key, string, <<"esp_stream_in">>}, {prefetch, integer, 1}].

init(NodeId, _Inputs, #{stream_ids := StreamIds, key := Key, prefetch := Prefetch}) ->
   io:format("~p init:node~n",[NodeId]),
   State0 = #state{stream_ids = StreamIds, key = Key, node_id = NodeId, prefetch = Prefetch},
   State = start_consumer(State0),
   {ok, none, State}.


process(_Inport, Value, State) ->
   io:format("~p process, ~p~n",[State, {_Inport, Value}]),
   {ok, State}.

handle_info({ {#'basic.deliver'{delivery_tag = DTag, routing_key = RKey},
   #'amqp_msg'{payload = Payload, props = #'P_basic'{headers = _Headers}}}, From}, State) ->
   process({RKey, Payload}, From, DTag, State),
   {ok, State};
handle_info({'DOWN', _MonitorRef, process, Consumer, _Info}, #state{data_handler = Consumer} = State) ->
   lager:notice("MQ-Consumer ~p is 'DOWN'",[Consumer]),
   {ok, start_consumer(State)};
handle_info(Request, State) ->
   io:format("~p request: ~p~n", [State, Request]),
   {ok, State}.

process(Val = {_StreamId, Value}, Consumer, MQTag, #state{} = _State) ->
   lager:info("~p process Event: ~p ~n",[?MODULE, Val]),
   Value1 = flowdata:stream_decode(Value),
   dataflow:emit(Value1),
   carrot:ack(Consumer, MQTag).

%% internal %%
start_consumer(State = #state{stream_ids = Inputs, key = Key, prefetch = Prefetch}) ->
   {ok, Pid, _Consumer} = carrot:start_monitored_consumer(consumer_config(Inputs, Key, Prefetch)),
   State#state{data_handler = Pid}
   .

-spec consumer_config([binary()], binary(), non_neg_integer()) -> list().
consumer_config(StreamIds, Key, Prefetch) when is_list(StreamIds) ->
   {ok, HostParams} = application:get_env(carrot, broker),
   Config =
      [
         {workers, 1},  % Number of connections, but not relevant here,
         % cause we start the consumer monitored
         {callback, self()},
         {setup_type, permanent},
         %% prefetch 1 item at a time ->
         %% the item will be acked as soon as it is persisted and so the next item will arrive
         {prefetch_count, Prefetch},
         {setup,
            [
               {queue, [
                  {queue, <<"qm_faxe_data_", Key/binary>>}, %% 'qm_' - queue expires after 1 hour of inactivity
                  {exchange, <<"x_ds_direct">>},
                  {routing_key, <<"">>},
                  {bindings, StreamIds}

               ]}
            ]
         }


      ],
   carrot_util:proplists_merge(HostParams, Config).

